// Package ec2 provides functions for interacting with EC2 instances on AWS.
package ec2

import (
	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/aws/session"
	"github.com/aws/aws-sdk-go/service/ec2"
	"github.com/jackstenglein/rest_api_creator/backend/errors"
	"github.com/jackstenglein/rest_api_creator/backend/log"
)

// deployer is an empty struct that acts as a collection of EC2 methods.
type deployer struct{}

// EC2 provides a high-level interface to perform AWS EC2 operations.
var EC2 = deployer{}

// service wraps the EC2 functions needed to provide functionality.
// This allows for easier dependency injection of the service.
type service interface {
	AuthorizeSecurityGroupIngress(*ec2.AuthorizeSecurityGroupIngressInput) (*ec2.AuthorizeSecurityGroupIngressOutput, error)
	CreateSecurityGroup(*ec2.CreateSecurityGroupInput) (*ec2.CreateSecurityGroupOutput, error)
	CreateTags(*ec2.CreateTagsInput) (*ec2.CreateTagsOutput, error)
	DescribeInstances(*ec2.DescribeInstancesInput) (*ec2.DescribeInstancesOutput, error)
	DescribeSecurityGroups(*ec2.DescribeSecurityGroupsInput) (*ec2.DescribeSecurityGroupsOutput, error)
	RunInstances(*ec2.RunInstancesInput) (*ec2.Reservation, error)
}

// defaultSvc is the service that actually queries EC2 and should be used in deployment.
var defaultSvc = ec2.New(session.New())

// svc is the service currently being used. The value of this variable should be changed only in unit tests
// when performing dependency injection.
var svc service = defaultSvc

const (
	// AuthorizeSecurityGroupIngress
	ingressPort     = 80
	ipProtocol      = "tcp"
	ipRangeAnywhere = "0.0.0.0/0"

	// CreateSecurityGroup
	securityGroupDescription = "Opens port 80 for use as a webserver. This security group was generated by CRUD Creator."
	securityGroupName        = "crudcreator-webserver"

	// RunInstance
	imageID      = "ami-0323c3dd2da7fb37d"
	instanceType = "t2.micro"
)

// addIngressRule adds an ingress rule to the default security group. The new rule allows all traffic
// on port 80.
func addIngressRule() error {
	input := &ec2.AuthorizeSecurityGroupIngressInput{
		CidrIp:     aws.String(ipRangeAnywhere),
		FromPort:   aws.Int64(ingressPort),
		GroupName:  aws.String(securityGroupName),
		IpProtocol: aws.String(ipProtocol),
		ToPort:     aws.Int64(ingressPort),
	}
	log.Info("Making call to AuthorizeSecurityGroupIngress with input: ", input)
	_, err := svc.AuthorizeSecurityGroupIngress(input)
	return errors.Wrap(err, "Failed call to AuthorizeSecurityGroupIngress")
}

// createSecurityGroup creates a security group with the default name.
func createSecurityGroup() error {
	input := &ec2.CreateSecurityGroupInput{
		Description: aws.String(securityGroupDescription),
		GroupName:   aws.String(securityGroupName),
	}
	log.Info("Making call to CreateSecurityGroup with input: ", input)
	_, err := svc.CreateSecurityGroup(input)
	return errors.Wrap(err, "Failed call to CreateSecurityGroup")
}

// DescribeInstance returns the instance with the given id.
func (deployer) DescribeInstance(instanceID string) (*ec2.Instance, error) {
	input := &ec2.DescribeInstancesInput{
		InstanceIds: []*string{aws.String(instanceID)},
	}

	log.Info("Making call to DescribeInstances with input:", input)
	result, err := svc.DescribeInstances(input)
	if err != nil {
		return nil, errors.Wrap(err, "Failed call to DescribeInstances")
	}
	log.Info("Got DescribeInstances result:", result)

	if len(result.Reservations) == 0 || len(result.Reservations[0].Instances) == 0 {
		return nil, errors.NewServer("DescribeInstances returned no results")
	}

	return result.Reservations[0].Instances[0], nil
}

// describeSecurityGroup returns the default CRUD security group, if it already exists. If it does not exist,
// nil is returned.
func describeSecurityGroup() (*ec2.SecurityGroup, error) {
	input := &ec2.DescribeSecurityGroupsInput{
		GroupNames: []*string{aws.String(securityGroupName)},
	}
	log.Info("Making call to DescribeSecurityGroups with input:", input)
	output, err := svc.DescribeSecurityGroups(input)
	if err != nil {
		return nil, errors.Wrap(err, "Failed call to DescribeSecurityGroups")
	}
	log.Info("DescribSecurityGroups output:", output)

	if len(output.SecurityGroups) == 0 {
		return nil, nil
	}

	return output.SecurityGroups[0], nil
}

// GetPublicURL returns the public DNS name of the instance with the given id.
func (deployer) GetPublicURL(instanceID string) (string, error) {
	instance, err := EC2.DescribeInstance(instanceID)
	if err != nil {
		return "", errors.Wrap(err, "Failed to describe instance")
	}
	return *instance.PublicDnsName, nil
}

// LaunchInstance creates an EC2 instance that runs the default project.
// If successful, it returns the new instance's ID and the public URL of the instance.
// TODO: pass in the project dynamically
func (deployer) LaunchInstance() (string, string, error) {

	securityGroup, err := describeSecurityGroup()
	if err != nil {
		return "", "", errors.Wrap(err, "Failed to get security group")
	}

	if securityGroup == nil {
		err = createSecurityGroup()
		if err != nil {
			return "", "", errors.Wrap(err, "Failed to create security group")
		}
	}

	if shouldAddIngressRule(securityGroup) {
		err = addIngressRule()
		if err != nil {
			return "", "", errors.Wrap(err, "Failed to add ingress rule to security group")
		}
	}

	instance, err := runInstance()
	if err != nil {
		return "", "", errors.Wrap(err, "Failed to run instance")
	}

	return *instance.InstanceId, *instance.PublicDnsName, nil
}

// runInstance creates a new EC2 instance with the default CRUD Creator security group and launches it.
// If successful, it returns the new instance id and the public URL of the instance.
func runInstance() (*ec2.Instance, error) {
	runInput := &ec2.RunInstancesInput{
		ImageId:      aws.String(imageID),
		InstanceType: aws.String(instanceType),
		MaxCount:     aws.Int64(1),
		MinCount:     aws.Int64(1),
		UserData:     aws.String(encUserData),
	}
	log.Info("Making call to RunInstances with input: ", runInput)

	result, err := svc.RunInstances(runInput)
	if err != nil {
		return nil, errors.Wrap(err, "Failed call to RunInstances")
	}
	log.Info("Got RunInstances result", result)

	if len(result.Instances) == 0 {
		return nil, errors.NewServer("RunInstances returned no instances")
	}
	instance := result.Instances[0]
	if instance.InstanceId == nil || *instance.InstanceId == "" {
		return nil, errors.NewServer("RunInstances did not return InstanceId")
	}

	tagInput := &ec2.CreateTagsInput{
		Resources: []*string{instance.InstanceId},
		Tags: []*ec2.Tag{
			{
				Key:   aws.String("Name"),
				Value: aws.String("CRUD Creator Server"),
			},
		},
	}
	log.Info("Making call to CreateTags with input: ", tagInput)
	_, err = svc.CreateTags(tagInput)

	log.Info("Created instance: ", instance)
	return instance, errors.Wrap(err, "Failed call to CreateTags")
}

// shouldAddIngressRule checks whether the given security group needs to add the HTTP port 80 all traffic rule.
func shouldAddIngressRule(group *ec2.SecurityGroup) bool {
	if group == nil {
		return true
	}
	if len(group.IpPermissions) == 0 {
		return true
	}

	rule := group.IpPermissions[0]
	if *rule.IpProtocol != ipProtocol {
		return true
	}
	if *rule.FromPort != ingressPort || *rule.ToPort != ingressPort {
		return true
	}
	if len(rule.IpRanges) == 0 {
		return true
	}

	ipRange := rule.IpRanges[0]
	if *ipRange.CidrIp != ipRangeAnywhere {
		return true
	}

	return false
}
